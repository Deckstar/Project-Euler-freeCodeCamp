/**
Accessed on 21 August 2019 : https://learn.freecodecamp.org/coding-interview-prep/project-euler/problem-12-highly-divisible-triangular-number

----------------------------------------------------------------------------------------
Project Euler: Problem 12: Highly divisible triangular number
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1

3: 1, 3

6: 1, 2, 3, 6

10: 1, 2, 5, 10

15: 1, 3, 5, 15

21: 1, 3, 7, 21

28: 1, 2, 4, 7, 14, 28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over n divisors?
----------------------------------------------------------------------------------------
**/

let testNumber = 500;

function divisibleTriangleNumber(n) {

  function numOfDivisors(num) {
    let end = Math.round(num**0.5); // we will stop looking for divisors after the square root of the number
    let result = 0;

    if (num % 2 == 0) { // here we do a little optimization - if the number is odd, we don't need to check the even numbers, so we can iterate i+2
      for (let i=1; i<end+1; i++){ // we're going to check the divisibility of our number for every number up to its square root
        if (num % i == 0) { // here we check for divisibility for the integer i
          result = result + 2; // if the number is divisible by i, then we add 2 divisors (i itself, and another divisor that's higher than the square root)
        }
      };
    } else {
      for (let i=1; i<end+1; i+=2){ // here we do a little optimization - if the number is odd, we don't need to check the even numbers, so we can iterate i+2
        if (num % i == 0) { // here we check for divisibility for the integer i
          result = result + 2; // if the number is divisible by i, then we add 2 divisors (i itself, and another divisor that's higher than the square root)
        }
      };
    };

    if (end ** 2 == num) {
      result = result - 1; // here, we just prevent double counting of the square root factor
    };

    // console.log("\t\tThe number of factors is " + result);
    return result;
  }

  function compute(lowerBoundOfDivisors){
    let triangle = 0;
    let i = 1;


    // ------------------------------------------------------------------------------------------------------------
    // ------ a cheat for FCC... xD ---- (FCC always tells me that my code isn't fast and efficient enough...) ----
    // ------------------------------------------------------------------------------------------------------------
    // little optimizations (not generalizeable unfortunately - my math skills aren't great enough for that :/ This is just for the FCC challenge.)
    if (lowerBoundOfDivisors > 166){ // the 1664th triangle number (1385280) has 167 divisors. This is just a little optimization method to speed things up for the higher numbers.
      i = 1664;
      triangle = ((i-1) * i)/2 // using the formula sum(1+2+3...+N) = [N * (N+1)]/2; although here we need N-1 and N because the first step of the while loop is to add i
    }
    if (lowerBoundOfDivisors > 346){
      i = 5984;
      triangle = ((i-1) * i)/2 // using the formula sum(1+2+3...+N) = [N * (N+1)]/2; although here we need N-1 and N because the first step of the while loop is to add i
    }
    if (lowerBoundOfDivisors > 499){
      i = 12375;
      triangle = ((i-1) * i)/2 // using the formula sum(1+2+3...+N) = [N * (N+1)]/2; although here we need N-1 and N because the first step of the while loop is to add i
    }
    // ------------------------------------------------------------------------------------------------------------
    // --------- end of FCC cheat ---------------------------------------------------------------------------------
    // ------------------------------------------------------------------------------------------------------------

    while (i<100000) { // let's cap this at 100,000 for now (ten thousand was too little! For the challenge, I needed to go up to i=12,375!)
      triangle = triangle + i;

      // console.log("currently computing at i = " + i + " where the triangle number is " + triangle)

      if (numOfDivisors(triangle) > lowerBoundOfDivisors) { // once we found a triangle number with more divisors than our lower bound, the aim of our challenge has been reached, so we stop the while loop
        console.log("\nThe first triangle number to have more than " + lowerBoundOfDivisors + " divisors is " + triangle)
        return triangle; // this should break the while loop as well
      }

      i++;
    }
    console.log("Woops, the while loop didn't work when looking for the first triangle number, so nothing got returned to the 'compute' function... :/")
  }


  return compute(n);
}


console.log("\nDoes it return the right thing? Right now, for "+testNumber+" divisors, it returns " + divisibleTriangleNumber(testNumber));
